
<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Clark Bode" />
  <meta name="viewport" content="width=device-width">
  <title></title>
  <style>
    html, body {
      padding: 0;
      margin: 0;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <script src="../Common/three.min.js"></script>
  <script>
  //TODO: Figure out how to apply a texture to the object, 
  //add rotation, more objects, rotation for those objects
  // IMPORTANT NOTE: TEXTURES ONLY WORK IN FIREFOX BECAUSE GOOGLE IS AN ASS.
  
	//set the scene size
	const sceneWIDTH = window.innerWidth;;
	const sceneHEIGHT = window.innerHeight;
	
	//set camera attribs
	const VIEW_ANGLE = 100;
	const ASPECT = sceneWIDTH / sceneHEIGHT;
	const NEAR = 0.1;
	const FAR = 100000;
	
	// Get the DOM element to attach to
	const container = document.querySelector('#container');
	
	// create a WebGL renderer, camera
	const renderer = new THREE.WebGLRenderer();
	const camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	
	// create textures
	const jupTexture = new THREE.TextureLoader().load( "jupiter.png" ); // texture name is placeholder
	const m1Texture = new THREE.TextureLoader().load("io.jpg");
	/*const m2Texture = new THREE.TextureLoader().load("europa.jpg"); //uncomment these as you add moons
	const m3Texture = new THREE.TextureLoader().load("ganymede.jpg");
	const m4Texture = new THREE.TextureLoader().load("callisto.jpg");
	*/
	// create scene
	const scene = new THREE.Scene();
	
	//add the camera to scene
	scene.add(camera);
	camera.position.z = 800;
	
	//start renderer
	renderer.setSize(sceneWIDTH, sceneHEIGHT);
	
	//attach the DOM elemet from the renderer
	container.appendChild(renderer.domElement);
	
	//set up objects' vars
	// Jupiter
	const jupRADIUS = 200;
	const jupSEGMENTS = 32;
	const jupRINGS = 32;
	
	// moon 1
	const m1RADIUS = 50;
	const m1SEGMENTS = 16;
	const m1RINGS = 16;
	
	//create jupiter's material (uses the jupTexture when creating the material and carries it wherever it goes)
	const jupMaterial = new THREE.MeshBasicMaterial( { map: jupTexture } );
	
	//create moon 1's material
	const m1Material = new THREE.MeshBasicMaterial( { map: m1Texture } );
	
	//Create meshes with sphere geometry
	//Jupiter
	const jupiter = new THREE.Mesh(

      new THREE.SphereGeometry(
        jupRADIUS,
        jupSEGMENTS,
        jupRINGS), jupMaterial//Material goes here, but is created WITH the texture.
		); 
		
	//Moon 1	
	const moon1 = new THREE.Mesh(
	
	  new THREE.SphereGeometry(
		m1RADIUS,
		m1SEGMENTS,
		m1RINGS), m1Material     //commented out because I don't have a texture yet. uncomment once you get a texture!
		);
	//Move the object into the desired place
	//jupiter
	//jupiter.position.z = -400;
	
	//moon1
	//moon1.position.z = -200;
	//moon1.translateZ(-400);
	var radius = 210;
	var moon1Rotate = 0; //this gets incremented in update()
	
	//add objects to scene
	scene.add(jupiter);
	scene.add(moon1);
	/*scene.add(moon2);
	scene.add(moon3);
	scene.add(moon4);
	*/

	
	//create some light
	const pointLight = new THREE.PointLight(0xFFFFF);
	
	//set light position
	pointLight.position.x = 10;
	pointLight.position.y = 50;
	pointLight.position.z = 130;
	
	//add to the scene
	scene.add(pointLight);
	
	
	
	function update () 
	{
      // Draw!
      renderer.render(scene, camera);

      // Schedule the next frame.
      requestAnimationFrame(update);
	  
	  //rotate objects (Is there a more performance-efficient way of doing this?)
	  //jupiter.rotateY(.00015);
	  //moon1.rotateY(.005);
	  moon1Rotate += 0.01;
	  
	  //moon1.translate((Math.cos(moon1Rotate % 360) * radius), 0, (Math.sin(moon1Rotate % 360) * radius));
	  moon1.translateX(Math.cos(moon1Rotate % (Math.PI * 2)) * radius);
	  moon1.translateY(Math.sin((moon1Rotate % (Math.PI * 2)) * radius));
	  
	 // moon1.translateZ(-400);
	  
	  //Orbits (method taken from StackOverflow https://stackoverflow.com/questions/42418958/rotate-an-object-around-an-orbit)
	  /*date = Date.now() * 0.0001;
		p1.position.set(
		Math.cos(date) * orbitRadius,
		0,
		Math.sin(date) * orbitRadius
		);*/
		
		//console.log(moon1.translateX);
		//console.log(moon1.translateZ);
    }

    // Schedule the first frame.
    requestAnimationFrame(update);
  </script>
</body>
</html>